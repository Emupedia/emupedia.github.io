var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var isWindows;
    if (typeof process === 'object') {
        isWindows = process.platform === 'win32';
    }
    else if (typeof navigator === 'object') {
        var userAgent = navigator.userAgent;
        isWindows = userAgent.indexOf('Windows') >= 0;
    }
    function isHighSurrogate(charCode) {
        return (0xD800 <= charCode && charCode <= 0xDBFF);
    }
    function isLowSurrogate(charCode) {
        return (0xDC00 <= charCode && charCode <= 0xDFFF);
    }
    function isLowerAsciiHex(code) {
        return code >= 97 /* a */ && code <= 102 /* f */;
    }
    function isLowerAsciiLetter(code) {
        return code >= 97 /* a */ && code <= 122 /* z */;
    }
    function isUpperAsciiLetter(code) {
        return code >= 65 /* A */ && code <= 90 /* Z */;
    }
    function isAsciiLetter(code) {
        return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
    }
    //#endregion
    var _schemeRegExp = /^\w[\w\d+.-]*$/;
    function _validateUri(ret) {
        // scheme, must be set
        if (!ret.scheme) {
            throw new Error("[UriError]: Scheme is missing: {scheme: \"\", authority: \"" + ret.authority + "\", path: \"" + ret.path + "\", query: \"" + ret.query + "\", fragment: \"" + ret.fragment + "\"}");
        }
        // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
        // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
        if (ret.scheme && !_schemeRegExp.test(ret.scheme)) {
            throw new Error('[UriError]: Scheme contains illegal characters.');
        }
        // path, http://tools.ietf.org/html/rfc3986#section-3.3
        // If a URI contains an authority component, then the path component
        // must either be empty or begin with a slash ("/") character.  If a URI
        // does not contain an authority component, then the path cannot begin
        // with two slash characters ("//").
        if (ret.path) {
            if (ret.authority) {
                if (ret.path.charCodeAt(0) !== 47 /* Slash */) {
                    throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                }
            }
            else {
                if (ret.path.charCodeAt(0) === 47 /* Slash */ && ret.path.charCodeAt(1) === 47 /* Slash */) {
                    throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                }
            }
        }
    }
    // graceful behaviour when scheme is missing: fallback to using 'file'-scheme
    function _schemeFix(scheme, strict) {
        if (!scheme) {
            if (strict) {
                throw new Error('[UriError]: A scheme must be provided');
            }
            else {
                // console.trace('BAD uri lacks scheme, falling back to file-scheme.');
                scheme = 'file';
            }
        }
        return scheme;
    }
    // implements a bit of https://tools.ietf.org/html/rfc3986#section-5
    function _referenceResolution(scheme, path) {
        // the slash-character is our 'default base' as we don't
        // support constructing URIs relative to other URIs. This
        // also means that we alter and potentially break paths.
        // see https://tools.ietf.org/html/rfc3986#section-5.1.4
        switch (scheme) {
            case 'https':
            case 'http':
            case 'file':
                if (!path) {
                    path = '/';
                }
                else if (path[0].charCodeAt(0) !== 47 /* Slash */) {
                    path = '/' + path;
                }
                break;
        }
        return path;
    }
    var _uriRegExp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    var _percentRegExp = /%/g;
    var _hashRegExp = /#/g;
    var _backslashRegExp = /\\/g;
    var _slashRegExp = /\//g;
    /**
     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
     * This class is a simple parser which creates the basic component parts
     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
     * and encoding.
     *
     *       foo://example.com:8042/over/there?name=ferret#nose
     *       \_/   \______________/\_________/ \_________/ \__/
     *        |           |            |            |        |
     *     scheme     authority       path        query   fragment
     *        |   _____________________|__
     *       / \ /                        \
     *       urn:example:animal:ferret:nose
     */
    var URI = /** @class */ (function () {
        /**
         * @internal
         */
        function URI(schemeOrData, authority, path, query, fragment) {
            if (typeof schemeOrData === 'object') {
                this.scheme = schemeOrData.scheme || '';
                this.authority = schemeOrData.authority || '';
                this.path = schemeOrData.path || '';
                this.query = schemeOrData.query || '';
                this.fragment = schemeOrData.fragment || '';
                // no validation because it's this URI
                // that creates uri components.
                // _validateUri(this);
            }
            else {
                this.scheme = _schemeFix(schemeOrData);
                this.authority = authority || '';
                this.path = _referenceResolution(this.scheme, path || '');
                this.query = query || '';
                this.fragment = fragment || '';
                _validateUri(this);
            }
        }
        URI.isUri = function (thing) {
            if (thing instanceof URI) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.authority === 'string'
                && typeof thing.fragment === 'string'
                && typeof thing.path === 'string'
                && typeof thing.query === 'string'
                && typeof thing.scheme === 'string'
                && typeof thing.fsPath === 'function'
                && typeof thing.with === 'function'
                && typeof thing.toString === 'function';
        };
        Object.defineProperty(URI.prototype, "fsPath", {
            // ---- filesystem path -----------------------
            /**
             * Returns a string representing the corresponding file system path of this URI.
             * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
             * platform specific path separator.
             *
             * * Will *not* validate the path for invalid characters and semantics.
             * * Will *not* look at the scheme of this URI.
             * * The result shall *not* be used for display purposes but for accessing a file on disk.
             *
             *
             * The *difference* to `URI#path` is the use of the platform specific separator and the handling
             * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
             *
             * ```ts
                const u = URI.parse('file://server/c$/folder/file.txt')
                u.authority === 'server'
                u.path === '/shares/c$/file.txt'
                u.fsPath === '\\server\c$\folder\file.txt'
            ```
             *
             * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
             * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
             * with URIs that represent files on disk (`file` scheme).
             */
            get: function () {
                return _toFsPath(this.scheme, this.authority, this.path);
            },
            enumerable: true,
            configurable: true
        });
        // ---- modify to new -------------------------
        URI.prototype.with = function (change) {
            if (!change) {
                return this;
            }
            var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
            if (scheme === undefined) {
                scheme = this.scheme;
            }
            else if (scheme === null) {
                scheme = '';
            }
            if (authority === undefined) {
                authority = this.authority;
            }
            else if (authority === null) {
                authority = '';
            }
            if (path === undefined) {
                path = this.path;
            }
            else if (path === null) {
                path = '';
            }
            if (query === undefined) {
                query = this.query;
            }
            else if (query === null) {
                query = '';
            }
            if (fragment === undefined) {
                fragment = this.fragment;
            }
            else if (fragment === null) {
                fragment = '';
            }
            if (scheme === this.scheme
                && authority === this.authority
                && path === this.path
                && query === this.query
                && fragment === this.fragment) {
                return this;
            }
            return new _URI(scheme, authority, path, query, fragment);
        };
        // ---- parse & validate ------------------------
        /**
         * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
         * `file:///usr/home`, or `scheme:with/path`.
         *
         * *Note:* When the input lacks a scheme then `file` is used.
         *
         * @param value A string which represents an URI (see `URI#toString`).
         */
        URI.parse = function (value, strict) {
            var match = _uriRegExp.exec(value);
            if (!match) {
                throw new Error("[UriError]: Invalid input: " + value);
            }
            var scheme = _schemeFix(match[2 /* scheme */], strict) || '';
            var authority = match[4 /* authority */] || '';
            var path = _referenceResolution(scheme, match[5 /* path */] || '');
            var query = match[7 /* query */] || '';
            var fragment = match[9 /* fragment */] || '';
            var result = new _URI(scheme, percentDecode(authority), percentDecode(path), percentDecode(query), percentDecode(fragment));
            result._external = _toExternal(_normalEncoder, scheme, authority, path, query, fragment);
            return result;
        };
        /**
         * Creates a new URI from a file system path, e.g. `c:\my\files`,
         * `/usr/home`, or `\\server\share\some\path`.
         *
         * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
         * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
         * `URI.parse('file://' + path)` because the path might contain characters that are
         * interpreted (# and ?). See the following sample:
         * ```ts
        const good = URI.file('/coding/c#/project1');
        good.scheme === 'file';
        good.path === '/coding/c#/project1';
        good.fragment === '';
        const bad = URI.parse('file://' + '/coding/c#/project1');
        bad.scheme === 'file';
        bad.path === '/coding/c'; // path is now broken
        bad.fragment === '/project1';
        ```
         *
         * @param path A file system path (see `URI#fsPath`)
         */
        URI.file = function (path) {
            var authority = '';
            // normalize to fwd-slashes on windows,
            // on other systems bwd-slashes are valid
            // filename character, eg /f\oo/ba\r.txt
            if (isWindows) {
                path = path.replace(_backslashRegExp, '/');
            }
            // check for authority as used in UNC shares
            // or use the path as given
            if (path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(1) === 47 /* Slash */) {
                var idx = path.indexOf('/', 2);
                if (idx === -1) {
                    authority = path.substring(2);
                    path = '/';
                }
                else {
                    authority = path.substring(2, idx);
                    path = path.substring(idx) || '/';
                }
            }
            // ensures that path starts with /
            path = _referenceResolution('file', path);
            // escape some vital characters
            authority = authority.replace(_percentRegExp, '%25');
            path = path.replace(_percentRegExp, '%25');
            path = path.replace(_hashRegExp, '%23');
            if (!isWindows) {
                path = path.replace(_backslashRegExp, '%5C');
            }
            return URI.parse('file://' + authority + path);
        };
        URI.from = function (components) {
            return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
        };
        // ---- printing/externalize ---------------------------
        /**
         * Creates a string representation for this URI. It's guaranteed that calling
         * `URI.parse` with the result of this function creates an URI which is equal
         * to this URI.
         *
         * * The result shall *not* be used for display purposes but for externalization or transport.
         * * The result will be encoded using the percentage encoding and encoding happens mostly
         * ignore the scheme-specific encoding rules.
         *
         * @param skipEncoding Do not encode the result, default is `false`
         */
        URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            return _toExternal(skipEncoding ? _minimalEncoder : _normalEncoder, this.scheme, this.authority, this.path, this.query, this.fragment);
        };
        URI.prototype.toJSON = function () {
            return this;
        };
        URI.revive = function (data) {
            if (!data) {
                return data;
            }
            else if (data instanceof URI) {
                return data;
            }
            else {
                var result = new _URI(data);
                result._external = data.external;
                result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
                return result;
            }
        };
        return URI;
    }());
    exports.URI = URI;
    var _pathSepMarker = isWindows ? 1 : undefined;
    // tslint:disable-next-line:class-name
    var _URI = /** @class */ (function (_super) {
        __extends(_URI, _super);
        function _URI() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._external = null;
            _this._fsPath = null;
            return _this;
        }
        Object.defineProperty(_URI.prototype, "fsPath", {
            get: function () {
                if (!this._fsPath) {
                    this._fsPath = _toFsPath(this.scheme, this.authority, this.path);
                }
                return this._fsPath;
            },
            enumerable: true,
            configurable: true
        });
        _URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            if (skipEncoding) {
                // we don't cache that
                return _toExternal(_minimalEncoder, this.scheme, this.authority, this.path, this.query, this.fragment);
            }
            if (!this._external) {
                this._external = _toExternal(_normalEncoder, this.scheme, this.authority, this.path, this.query, this.fragment);
            }
            return this._external;
        };
        _URI.prototype.toJSON = function () {
            var res = {
                $mid: 1
            };
            // cached state
            if (this._fsPath) {
                res.fsPath = this._fsPath;
                res._sep = _pathSepMarker;
            }
            if (this._external) {
                res.external = this._external;
            }
            // uri components
            if (this.path) {
                res.path = this.path;
            }
            if (this.scheme) {
                res.scheme = this.scheme;
            }
            if (this.authority) {
                res.authority = this.authority;
            }
            if (this.query) {
                res.query = this.query;
            }
            if (this.fragment) {
                res.fragment = this.fragment;
            }
            return res;
        };
        return _URI;
    }(URI));
    /**
     * Compute `fsPath` for the given uri
     */
    function _toFsPath(scheme, authority, path) {
        var value;
        if (authority && path.length > 1 && scheme === 'file') {
            // unc path: file://shares/c$/far/boo
            value = "//" + authority + path;
        }
        else if (path.charCodeAt(0) === 47 /* Slash */
            && isAsciiLetter(path.charCodeAt(1))
            && path.charCodeAt(2) === 58 /* Colon */) {
            // windows drive letter: file:///c:/far/boo
            value = path[1].toLowerCase() + path.substr(2);
        }
        else {
            // other path
            value = path;
        }
        if (isWindows) {
            value = value.replace(_slashRegExp, '\\');
        }
        return value;
    }
    //#region ---- decode
    function decodeURIComponentGraceful(str) {
        try {
            return decodeURIComponent(str);
        }
        catch (_a) {
            if (str.length > 3) {
                return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
            }
            else {
                return str;
            }
        }
    }
    var _encodedAsHexRegExp = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function percentDecode(str) {
        if (!str.match(_encodedAsHexRegExp)) {
            return str;
        }
        return str.replace(_encodedAsHexRegExp, function (match) { return decodeURIComponentGraceful(match); });
    }
    //#endregion
    //#region ---- encode
    // https://url.spec.whatwg.org/#percent-encoded-bytes
    // "The C0 control percent-encode set are the C0 controls and all code points greater than U+007E (~)."
    function isC0ControlPercentEncodeSet(code) {
        return code <= 0x1F || code > 0x7E;
    }
    // "The fragment percent-encode set is the C0 control percent-encode set and U+0020 SPACE, U+0022 ("), U+003C (<), U+003E (>), and U+0060 (`)."
    function isFragmentPercentEncodeSet(code) {
        return isC0ControlPercentEncodeSet(code)
            || code === 0x20 || code === 0x22 || code === 0x3C || code === 0x3E || code === 0x60;
    }
    // "The path percent-encode set is the fragment percent-encode set and U+0023 (#), U+003F (?), U+007B ({), and U+007D (})."
    function isPathPercentEncodeSet(code) {
        return isFragmentPercentEncodeSet(code)
            || code === 0x23 || code === 0x3F || code === 0x7B || code === 0x7D;
    }
    // "The userinfo percent-encode set is the path percent-encode set and U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([), U+005C (\), U+005D (]), U+005E (^), and U+007C (|)."
    function isUserInfoPercentEncodeSet(code) {
        return isPathPercentEncodeSet(code)
            || code === 0x2F || code === 0x3A || code === 0x3B || code === 0x3D || code === 0x40
            || code === 0x5B || code === 0x5C || code === 0x5D || code === 0x5E || code === 0x7C;
    }
    // https://url.spec.whatwg.org/#query-state
    function isQueryPrecentEncodeSet(code) {
        return code < 0x21 || code > 0x7E
            || code === 0x22 || code === 0x23 || code === 0x3C || code === 0x3E
            || code === 0x27; // <- todo@joh https://url.spec.whatwg.org/#is-special
    }
    // this is non-standard and uses for `URI.toString(true)`
    function isHashOrQuestionMark(code) {
        return code === 35 /* Hash */ || code === 63 /* QuestionMark */;
    }
    var _encodeTable = (function () {
        var table = [];
        for (var code = 0; code < 128; code++) {
            table[code] = "%" + code.toString(16);
        }
        return table;
    })();
    function percentEncode(str, mustEncode) {
        var lazyOutStr;
        for (var pos = 0; pos < str.length; pos++) {
            var code = str.charCodeAt(pos);
            // invoke encodeURIComponent when needed
            if (mustEncode(code)) {
                if (!lazyOutStr) {
                    lazyOutStr = str.substr(0, pos);
                }
                if (isHighSurrogate(code)) {
                    // Append encoded version of this surrogate pair (2 characters)
                    if (pos + 1 < str.length && isLowSurrogate(str.charCodeAt(pos + 1))) {
                        lazyOutStr += encodeURIComponent(str.substr(pos, 2));
                        pos += 1;
                    }
                    else {
                        // broken surrogate pair
                        lazyOutStr += str.charAt(pos);
                    }
                }
                else {
                    // Append encoded version of the current character, use lookup table
                    // to speed up repeated encoding of the same characters.
                    if (code < _encodeTable.length) {
                        lazyOutStr += _encodeTable[code];
                    }
                    else {
                        lazyOutStr += encodeURIComponent(str.charAt(pos));
                    }
                }
                continue;
            }
            // normalize percent encoded sequences to upper case
            // todo@joh also changes invalid sequences
            if (code === 37 /* PercentSign */
                && pos + 2 < str.length
                && (isLowerAsciiHex(str.charCodeAt(pos + 1)) || isLowerAsciiHex(str.charCodeAt(pos + 2)))) {
                if (!lazyOutStr) {
                    lazyOutStr = str.substr(0, pos);
                }
                lazyOutStr += '%' + str.substr(pos + 1, 2).toUpperCase();
                pos += 2;
                continue;
            }
            // once started, continue to build up lazy output
            if (lazyOutStr) {
                lazyOutStr += str.charAt(pos);
            }
        }
        return lazyOutStr || str;
    }
    var _normalEncoder = [isUserInfoPercentEncodeSet, isC0ControlPercentEncodeSet, isPathPercentEncodeSet, isQueryPrecentEncodeSet, isFragmentPercentEncodeSet];
    var _minimalEncoder = [isHashOrQuestionMark, isHashOrQuestionMark, isHashOrQuestionMark, isHashOrQuestionMark, function () { return false; }];
    var _driveLetterRegExp = /^(\/?[a-z])(:|%3a)/i;
    /**
     * Create the external version of a uri
     */
    function _toExternal(encoder, scheme, authority, path, query, fragment) {
        var res = '';
        if (scheme) {
            res += scheme;
            res += ':';
        }
        if (authority || scheme === 'file') {
            res += '//';
        }
        if (authority) {
            var idxUserInfo = authority.indexOf('@');
            if (idxUserInfo !== -1) {
                // <user:token>
                var userInfo = authority.substr(0, idxUserInfo);
                var idxPasswordOrToken = userInfo.indexOf(':');
                if (idxPasswordOrToken !== -1) {
                    res += percentEncode(userInfo.substr(0, idxPasswordOrToken), encoder[0 /* user */]);
                    res += ':';
                    res += percentEncode(userInfo.substr(idxPasswordOrToken + 1), encoder[0 /* user */]);
                }
                else {
                    res += percentEncode(userInfo, encoder[0 /* user */]);
                }
                res += '@';
            }
            authority = authority.substr(idxUserInfo + 1).toLowerCase();
            var idxPort = authority.indexOf(':');
            if (idxPort !== -1) {
                // <authority>:<port>
                res += percentEncode(authority.substr(0, idxPort), encoder[1 /* authority */]);
                res += ':';
            }
            res += percentEncode(authority.substr(idxPort + 1), encoder[1 /* authority */]);
        }
        if (path) {
            // encode the path
            var pathEncoded = percentEncode(path, encoder[2 /* path */]);
            // lower-case windows drive letters in /C:/fff or C:/fff and escape `:`
            var match = _driveLetterRegExp.exec(pathEncoded);
            if (match) {
                pathEncoded = match[1].toLowerCase() + '%3A' + pathEncoded.substr(match[0].length);
            }
            res += pathEncoded;
        }
        if (query) {
            res += '?';
            res += percentEncode(query, encoder[3 /* query */]);
        }
        if (fragment) {
            res += '#';
            res += percentEncode(fragment, encoder[4 /* fragment */]);
        }
        return res;
    }
});
//#endregion
